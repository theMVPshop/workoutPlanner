{"ast":null,"code":"import { OpenAIError } from \"./error.mjs\";\nexport class Stream {\n  constructor(response, controller) {\n    this.response = response;\n    this.controller = controller;\n    this.decoder = new SSEDecoder();\n  }\n  async *iterMessages() {\n    if (!this.response.body) {\n      this.controller.abort();\n      throw new OpenAIError(`Attempted to iterate over a response with no body`);\n    }\n    const lineDecoder = new LineDecoder();\n    const iter = readableStreamAsyncIterable(this.response.body);\n    for await (const chunk of iter) {\n      for (const line of lineDecoder.decode(chunk)) {\n        const sse = this.decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n    for (const line of lineDecoder.flush()) {\n      const sse = this.decoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n  async *[Symbol.asyncIterator]() {\n    let done = false;\n    try {\n      for await (const sse of this.iterMessages()) {\n        if (done) continue;\n        if (sse.data.startsWith('[DONE]')) {\n          done = true;\n          continue;\n        }\n        if (sse.event === null) {\n          try {\n            yield JSON.parse(sse.data);\n          } catch (e) {\n            console.error(`Could not parse message into JSON:`, sse.data);\n            console.error(`From chunk:`, sse.raw);\n            throw e;\n          }\n        }\n      }\n      done = true;\n    } catch (e) {\n      // If the user calls `stream.controller.abort()`, we should exit without throwing.\n      if (e instanceof Error && e.name === 'AbortError') return;\n      throw e;\n    } finally {\n      // If the user `break`s, abort the ongoing request.\n      if (!done) this.controller.abort();\n    }\n  }\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n  decode(chunk) {\n    let text = this.decodeText(chunk);\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n    if (!text) {\n      return [];\n    }\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]);\n      return [];\n    }\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n    return lines;\n  }\n  decodeText(bytes) {\n    var _a;\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n    }\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        (_a = this.textDecoder) !== null && _a !== void 0 ? _a : this.textDecoder = new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n    }\n    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n  }\n  flush() {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result === null || result === void 0 ? void 0 : result.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["OpenAIError","Stream","constructor","response","controller","decoder","SSEDecoder","iterMessages","body","abort","lineDecoder","LineDecoder","iter","readableStreamAsyncIterable","chunk","line","decode","sse","flush","Symbol","asyncIterator","done","data","startsWith","event","JSON","parse","e","console","error","raw","Error","name","chunks","endsWith","substring","length","join","push","fieldname","_","value","partition","buffer","trailingCR","text","decodeText","slice","trailingNewline","NEWLINE_CHARS","has","lines","split","NEWLINE_REGEXP","pop","bytes","Buffer","toString","Uint8Array","from","TextDecoder","ArrayBuffer","_a","textDecoder","Set","str","delimiter","index","indexOf","stream","reader","getReader","next","result","read","releaseLock","return","cancelPromise","cancel","undefined"],"sources":["C:\\Users\\12818\\Documents\\MVPworkshop\\workoutPlanner\\sweat-smart\\node_modules\\openai\\src\\streaming.ts"],"sourcesContent":["import { type Response } from './_shims/index';\nimport { OpenAIError } from './error';\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\ntype ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  private response: Response;\n  private decoder: SSEDecoder;\n\n  constructor(response: Response, controller: AbortController) {\n    this.response = response;\n    this.controller = controller;\n    this.decoder = new SSEDecoder();\n  }\n\n  private async *iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\n    if (!this.response.body) {\n      this.controller.abort();\n      throw new OpenAIError(`Attempted to iterate over a response with no body`);\n    }\n    const lineDecoder = new LineDecoder();\n\n    const iter = readableStreamAsyncIterable<Bytes>(this.response.body);\n    for await (const chunk of iter) {\n      for (const line of lineDecoder.decode(chunk)) {\n        const sse = this.decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n\n    for (const line of lineDecoder.flush()) {\n      const sse = this.decoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Item, any, undefined> {\n    let done = false;\n    try {\n      for await (const sse of this.iterMessages()) {\n        if (done) continue;\n\n        if (sse.data.startsWith('[DONE]')) {\n          done = true;\n          continue;\n        }\n\n        if (sse.event === null) {\n          try {\n            yield JSON.parse(sse.data);\n          } catch (e) {\n            console.error(`Could not parse message into JSON:`, sse.data);\n            console.error(`From chunk:`, sse.raw);\n            throw e;\n          }\n        }\n      }\n      done = true;\n    } catch (e) {\n      // If the user calls `stream.controller.abort()`, we should exit without throwing.\n      if (e instanceof Error && e.name === 'AbortError') return;\n      throw e;\n    } finally {\n      // If the user `break`s, abort the ongoing request.\n      if (!done) this.controller.abort();\n    }\n  }\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n\n  buffer: string[];\n  trailingCR: boolean;\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk: Bytes): string[] {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]!);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes: Bytes): string {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new OpenAIError(\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n      );\n    }\n\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ??= new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new OpenAIError(\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\n          (bytes as any).constructor.name\n        }) in a web platform. Please report this error.`,\n      );\n    }\n\n    throw new OpenAIError(\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n    );\n  }\n\n  flush(): string[] {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}